import uuid
from datetime import datetime
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, HttpUrl, validator

# --- Base Schemas ---
# Contain fields common to both creation and reading

class UserBase(BaseModel):
    username: str
    role: str = Field(..., pattern="^(admin|data_analyst)$") # Enforce role values
    is_active: bool = True

class SourceBase(BaseModel):
    name: str
    type: str = Field(..., pattern="^(website|rss|local|s3)$") # Enforce type values
    location: str # Could be URL or path
    config: Optional[Dict[str, Any]] = None
    is_active: bool = True

class ArticleBase(BaseModel):
    title: Optional[str] = None
    content_text: Optional[str] = None
    original_url: Optional[HttpUrl | str] = None # Allow general strings too initially
    source_format: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    # language: Optional[str] = Field(None, max_length=2) # e.g., 'en', 'es'
    # extracted_via_ocr: Optional[bool] = False

# --- Schemas for Creating Resources ---
# Used for request bodies when creating new items (e.g., POST requests)

class UserCreate(UserBase):
    password: str # Plain text password on creation, will be hashed before saving

class SourceCreate(SourceBase):
    pass # No extra fields needed beyond the base for creation initially

class ArticleCreate(ArticleBase):
    # Usually articles are created by the ingestion pipeline, but this
    # schema allows manual creation via API for testing (as per plan 1.2)
    source_id: Optional[uuid.UUID] = None # Allow associating with a source


# --- Schemas for Reading Resources ---
# Used for response bodies when returning items (e.g., GET requests)
# Includes fields generated by the database (like IDs, timestamps)

class User(UserBase):
    user_id: uuid.UUID
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True # Pydantic v2 alias for orm_mode

class Source(SourceBase):
    source_id: uuid.UUID
    last_run_timestamp: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class Article(ArticleBase):
    article_id: uuid.UUID
    source_id: Optional[uuid.UUID] = None
    extraction_date: datetime
    # checksum: Optional[str] = None
    last_nlp_run_timestamp: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True


# --- Schemas for other models (can be expanded later) ---

class AnnotationBase(BaseModel):
    type: str = Field(..., pattern="^(TAG|COMMENT)$")
    content: str

class AnnotationCreate(AnnotationBase):
    article_id: uuid.UUID
    # user_id will likely come from the authenticated user context

class Annotation(AnnotationBase):
    annotation_id: uuid.UUID
    article_id: uuid.UUID
    user_id: Optional[uuid.UUID] = None # User might be deleted (SET NULL)
    created_at: datetime

    class Config:
        from_attributes = True


class NamedEntityBase(BaseModel):
    entity_text: str
    normalized_form: str
    entity_type: str
    language: Optional[str] = Field(None, max_length=2)

class NamedEntityCreate(NamedEntityBase):
    pass # Usually created by NLP pipeline

class NamedEntity(NamedEntityBase):
    entity_id: uuid.UUID
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class JobRunBase(BaseModel):
    job_name: str
    status: str = Field(..., pattern="^(PENDING|RUNNING|SUCCESS|FAILED|PARTIAL)$")
    processed_count: int = 0
    error_count: int = 0
    details: Optional[Dict[str, Any]] = None

class JobRunCreate(JobRunBase):
    # started_at is usually set on creation
    pass

class JobRun(JobRunBase):
    job_run_id: uuid.UUID
    started_at: datetime
    finished_at: Optional[datetime] = None
    created_at: datetime
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

# Add Cluster schemas if needed for API endpoints later
# class ClusterBase(BaseModel): ...
# class ClusterCreate(ClusterBase): ...
# class Cluster(ClusterBase): ...
